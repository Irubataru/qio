% -*-LaTeX-*- document QDP/C QIO API (C Language Binding) version 0.8
%
\documentclass{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Prototype elements
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\allTypes}{{\tt S, I, R, C, V, H, D, M, P}}
\newcommand{\allQLATypes}{{\tt s, i, r, c, v, h, d, m, p}}
\newcommand{\itt}{\it T}
\newcommand{\itQLAt}{\it t}
\newcommand{\QMDhandle}{{\tt QDP\_String }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{
   Input/Output for QDP \\{\large Version 0.8}
}
\author{ SciDAC Software Coordinating Committee}

\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This document describes the C binding for the Input/Output
Applications Programmer Interface developed under the auspices of the
U.S. Department of Energy Scientific Discovery through Advanced
Computing (SciDAC) program.

This interface provides for (1) moving QDP lattice fields, QLA global
data, and strings to and from files and (2) creating and extracting
physics metadata for describing these fields.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview of File Format}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec.fileformat}

\subsection{Binary QDP Files}

The binary file format has been designed with flexibility in mind. For
archiving purposes, the allowable file organization may be further
restricted.  Here we described the unrestricted format.

Two classes of file volumes are supported: single-file volumes and
multiple-file volumes.  In the latter case lattice data is scattered
among several files for distributed reading and writing.  In the
former case all the lattice data is contained in a single file.

\subsubsection{Single file format}

Single binary QDP files are composed of a series of one or more
application records.  A single application record encodes a single QDP
field or an array of QDP fields of the same data type.  Physics
metadata, managed at the convenience of the applications programmer,
is associated with the file itself and with each application record as
well. Above the API the QDP file is viewed as follows:
%
\begin{itemize}
  \item File physics metadata
  \item Record 1 physics metadata and data
  \item Record 2 physics metadata and data
  \item etc.
\end{itemize}
%
For example, a file might record a series of staggered fermion
eigenvectors for a gauge field configuration.  Each record would map
to a single field of type \verb|QDP_ColorVector|.  The file metadata
might include information about the gauge field configuration and the
record metadata might encode the eigenvalue and an index for the
eigenvector.

For another example, the gauge field configuration in four dimensions
is represented in QDP as an array of four color matrix fields.  The
configuration is conventionally written so that the four color matrices
associated with each site appear together.  A file containing a single
gauge field configuration would then consist of a single record
containing the array of four color matrices.

The API permits mixing records of different datatypes in the same
file.  While this practice may be convenient for managing projects, it
may be forbidden for archival files.

Additional metadata is automatically managed by QIO (without requiring
intervention by the applications programmer) to facilitate the
implementation and to check data integrity.  Thus the file actually
begins with QIO metadata and physics metadata and each application
record consists of five logical records.  Within QIO the file is
viewed as a series of logical records as follows:
%
\begin{itemize}
  \item Private file QIO metadata
  \item User file physics metadata
  \item Record 1 private QIO metadata
  \item Record 1 user physics metadata
  \item Record 1 binary data
  \item Record 1 private checksum
  \item Record 2 private QIO metadata
  \item Record 2 user physics metadata
  \item Record 2 binary data
  \item Record 2 private checksum
  \item etc.
\end{itemize}
%
The site order of the binary data is lexicographic according to the
site coordinate $r_i$ with the first coordinate $r_0$ varying most
rapidly.

We use our own ``LIME'' format (Lattice QCD Interchange Message
Encapsulation) (a simplified version of DIME) for packaging the
logical records.  The management of physical files is handled
internally and is hidden from the applications programmer.

\subsection{Multifile format}

The API provides for rapid temporary writing of data to scratch disks
and reading from scratch disks.  This same format may be used for
staging files for access by many compute nodes.  In this case it is
assumed that the files are not intended for longer term storage.  Thus
the file format in this case is implementation-dependent and not
standardized.  A specific choice of format is described in the
Appendix.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Types Supported}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The API provides for binary file operation for writing and reading
lattice fields consisting of any of the QDP types, for writing and
reading global data of any of the QLA types or QDP strings.  The
multifile format applies only to files containing at least one lattice
field, but mixing of global and field records is permitted.

The API also provides for ASCII global printf and scanf operations
involving system standard output and input devices.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Metadata Standard and Manipulation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Metadata is required by a number of components in the I/O system.  We
are currently formulating an XML standard for the metadata and an API
for manipulating the metadata.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{QDP/C API}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Opening and closing binary files}

As with standard Unix, a file must be opened before reading or
writing.  However, we distinguish file handles for both cases.  If the
system provides a parallel file system, it is possible for several
processors to read and write a single file. We call this mode
``parallel''.  Otherwise the file is read by a single processor and
the data delivered according to the distributed memory layout.  The
reverse occurs upon writing. We call this mode ``serial''. To allow
user choice where the architecture permits, we provide for requesting
either mode.  However, the request may be overridden if the system
permits only one mode.  Upon writing, we allow appending to an
existing file.

\paragraph{Open a file for writing}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|QDP_Writer *QDP_open_write(|\QMDhandle \verb|*xml_file,|\\
                 & \verb| char *filename, int volfmt, int serpar, int mode);| \\
    \hline
  Purpose        & Opens a named file for writing and writes the file metadata. \\
\hline
  Example  & \verb|QDP_Writer *outfile;| \\
           & \verb|outfile = QDP_open_write(xml_file_out, filename, |\\
	   & \verb|  QDP_SINGLEFILE, QDP_SERIAL, QDP_CREATE); |\\
   \hline
 \end{tabular}
\end{flushleft}
%
The \verb|QDP_Writer| return value is the file handle used in
subsequent references to the file.  A null return value signals an
error. The IO system takes responsibility for allocating and freeing
space for the handle.  It is assumed the user has already created the
file metadata and provides the \QMDhandle, so it can be written
at the head of the file.  The \verb|volfmt| argument is one of
%
\begin{verbatim}
  QDP_SINGLEFILE, QDP_MULTIFILE
\end{verbatim}
%
The \verb|serpar| argument is one of
%
\begin{verbatim}
  QDP_SERIAL, QDP_PARALLEL
\end{verbatim}
%
and the \verb|mode| argument is one of
%
\begin{verbatim}
  QDP_CREATE, QDP_OPEN, QDP_APPEND
\end{verbatim}
%
where \verb|QDP_CREATE| fails if the file already exists,
\verb|QDP_OPEN| overwrites the file if it already exists and creates
it if not, and \verb|QDP_APPEND| fails if the file does not exist and
otherwise appends at the end of the file.  When appending, the file
metadata argument is ignored, since it should already exist.

The user supplies the dimension of the space and the extent of the
lattice coordinates.

\paragraph{Open a file for reading}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|QDP_Reader *QDP_open_read(|\QMDhandle \verb| *xml_file,|\\
                 & \verb| char *filename, int serpar);|\\
    \hline
  Purpose        & Opens a named file for reading and reads the file metadata. \\
\hline
  Example  & \verb|QDP_Reader *infile;| \\
           & \verb|outfile = QDP_open_read(xml_file_in, filename, |\\
	   & \verb|  QDP_SERIAL);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
The \verb|QDP_Reader| return value is the file handle used in
subsequent references to the file.  A null return value signals an
error. The IO system takes responsibility for allocating and freeing
space for the handle.  It is assumed the user has created space for
the file metadata with address \verb|xml_file|, so it can be read from
the head of the file and inserted.  The other arguments have the same
meaning as with \verb|QDP_open_write|.  The volume format is
autodetected, so is not specified.
%
\paragraph{Close an output file}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QDP_close_write(QDP_Writer *out);| \\
    \hline
  Purpose        & Closes an output file. \\
\hline
  Example        & \verb|QDP_close_write(outfile);|\\
   \hline
 \end{tabular}
\end{flushleft}
%
\paragraph{Close an input file}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QDP_close_read(QDP_Reader *in);| \\
    \hline
  Purpose        & Closes an input file. \\
\hline
  Example        & \verb|QDP_close_read(infile);|\\
   \hline
 \end{tabular}
\end{flushleft}
%
In both cases the integer return value is 0 for success and 1 for failure.

\subsection{Opening and closing ASCII metadata files}
[Not described, yet]

\subsection{Writing and reading QDP fields}

\paragraph{Writing a field}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QDP_write_|\itt\verb|(QDP_Writer *out,|\\
                 &  \QMDhandle \verb|*xml_record, QDP_|{\it Type}\verb| *field);|\\
    \hline
  Purpose        & Writes the field and its metadata as the next record in \\
                 & the specified file. \\
\hline
  \itt     & \allTypes \\
   \hline
  Example  & \verb|QDP_Real *field_out;| \\
           & \verb|QDP_write_R(outfile, xml_record_out, field_out);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
The integer return value is 0 for success and 1 for failure.  It is
assumed the user has prepared the record metadata and the field data
in advance.

\paragraph{Reading a field}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QDP_read_|\itt\verb|(QDP_Reader *in,|\\
                 &  \QMDhandle \verb|*xml_record, QDP_|{\it Type}\verb| *field);|\\
    \hline
  Purpose        & Reads the field and its metadata from the next record \\
                 & in the specified file. \\
\hline
  \itt     & \allTypes \\
   \hline
  Example  & \verb|QDP_Real *field_out;| \\
           & \verb|QDP_read_R(infile, xml_record_in, field_in);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
The integer return value is 0 for success and 1 for failure.  It is
assumed the user has prepared space for the record metadata and the
field data in advance.  The datatype of the record must match the
field type.

\paragraph{Writing an array of fields}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QDP_write_v|\itt\verb|(QDP_Writer *out, |\\
                 & \QMDhandle \verb|*xml_record, QDP_|{\it Type}\verb| *field, int n);|\\
    \hline
  Purpose        & Writes the array of fields and its metadata as the next \\
                 & record in the specified file. \\
\hline
  \itt     & \allTypes \\
   \hline
  Example  & \verb|QDP_ColorMatrix field[4];| \\
           & \verb|QDP_write_vM(outfile, xml_record_out, field, 4);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
The integer return value is 0 for success and 1 for failure.  It is
assumed the user has prepared the record metadata and the field data
in advance.

\paragraph{Reading an array of fields}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QDP_read_v|\itt\verb|(QDP_Reader *in, |\\
                 &   \QMDhandle \verb|*xml_record, QDP_|{\it Type}\verb| *field, int n);|\\
    \hline
  Purpose        & Reads the array of fields and its metadata from the next \\
                 & record in the specified file. \\
\hline
  \itt     & \allTypes \\
   \hline
  Example  & \verb|QDP_ColorMatrix field[4];| \\
           & \verb|QDP_read_vM(infile, xml_record_in, field, 4);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
The integer return value is 0 for success and 1 for failure.  It is
assumed the user has prepared space for the record metadata and the
field data in advance.

\paragraph{Reading only the record information}

It may be convenient to examine the record metadata to decide whether
to read or skip the accompanying binary data.

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QDP_read_record_info(QDP_Reader *in,|\\
                 &  \QMDhandle \verb|*xml_record);|\\
    \hline
  Purpose        & Reads the only the metadata from the next record in the \\
                 & specified file. \\
   \hline
  Example  & \verb|QDP_read_record_info(infile, xml_record_in);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
A subsequent call to \verb|QDP_read_T| returns a copy of the same
metadata along with the lattice field.

\paragraph{Skipping to the next record}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QDP_next_record(QDP_Reader *in);|\\
    \hline
  Purpose        & Advances to the beginning of the next record. \\
   \hline
  Example  & \verb|QDP_next_record(infile);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
\subsection{Writing and reading QLA arrays}

QLA data is single processor data that carries no lattice site index.
Typically these values result from a global reduction. For example, a
correlation function might be computed on every time slice of the
lattice and summed globally over the entire machine.  From the
standpoint of data parallel I/O operation the data is treated as a
global quantity with the same name and value on every processor.  When
it is written to a file, it is assumed that the values are the same on
each node, so only one node needs to write its value.  When it is read
from a file, the I/O system does a broadcast to every node, so the
result of reading is a global value.

An interface is provided for reading and writing arrays of QLA data.
Single QLA values can be passed as an array of length one.  The naming
conventions for the routines follow conventions of the QDP API.
Notice that the encoded QLA data type is lower case and the argument is a
pointer to a QLA type.

\paragraph{Writing an array of QLA values}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QDP_write_v|\itQLAt\verb|(QDP_Writer *out, |\\
                 & \QMDhandle \verb|*xml_record, QLA_|{\it Type}\verb| *array, int n);|\\
    \hline
  Purpose        & Writes the QLA array and its metadata as the next \\
                 & record in the specified file. \\
\hline
  \itQLAt     & \allQLATypes \\
   \hline
  Example  & \verb|QLA_ColorMatrix array[4];| \\
           & \verb|QDP_write_vm(outfile, xml_record_out, array, 4);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
The integer return value is 0 for success and 1 for failure.  It is
assumed the user has prepared the record metadata and the field data
in advance.

\paragraph{Reading a QLA array}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QDP_read_v|\itQLAt\verb|(QDP_Reader *in, |\\
                 &   \QMDhandle \verb|*xml_record, QLA_|{\it Type}\verb| *array, int n);|\\
    \hline
  Purpose        & Reads the QLA array and its metadata from the next \\
                 & record in the specified file. \\
\hline
  \itQLAt     & \allQLATypes \\
   \hline
  Example  & \verb|QLA_ColorMatrix array[4];| \\
           & \verb|QDP_read_vm(infile, xml_record_in, array, 4);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
The integer return value is 0 for success and 1 for failure.  It is
assumed the user has prepared space for the record metadata and the
field data in advance.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{String Handling}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A separate SciDAC package currently under development provides the
tools for constructing XML documents.  For I/O they must be converted
to ``QDP strings''.  A few utilities are provided for manipulating the
QDP string type \QMDhandle required by the API\@.

\paragraph{Creating an empty QDP String}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \QMDhandle \verb|*QDP_string_create(int length);|\\
    \hline
  Purpose        & Creates an empty string of length \verb|length|. \\
   \hline
  Example        & \verb|fileinfo = QDP_string_create(MAX);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
\paragraph{Creating a QDP string from a null-terminated character array}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \QMDhandle \verb|*QDP_string_set(| \\
                 & \verb| const char *const string);|\\
    \hline
  Purpose        & Creates a QDP string containing the null-terminated \\
                 & character array \verb|string|. \\
   \hline
  Example        & \verb|QDP_string *fileinfo;| \\
                 & \verb|fileinfo = QDP_string_set(string);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
\paragraph{Copying a QDP string}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \QMDhandle \verb|*QDP_string_copy(|\QMDhandle \verb|*dest,| \QMDhandle \verb|*src);|\\
    \hline
  Purpose        & Copies the string. \\
   \hline
  Example        & \verb|QDP_string_copy(newxml,oldxml);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
\paragraph{Reallocating a QDP string}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \QMDhandle \verb|*QDP_string_realloc(|\QMDhandle \verb| *xml, int length);|\\
    \hline
  Purpose        & Adjusts space allocated for string. \\
   \hline
  Example        & \verb|QDP_string_realloc(oldxml, NEWMAX);| \\
   \hline
 \end{tabular}
\end{flushleft}
Adjusts string length to a new length with null padding or truncation
if necessary.
%
\paragraph{Accessing the character string}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|char *QDP_string_bytes(const |\QMDhandle \verb|*const xml);|\\
    \hline
  Purpose        & Returns a pointer to the null-terminated character array \\
                 & in the string. \\
   \hline
  Example        & \verb|printf("%s\n", QDP_string_bytes(xml));| \\
   \hline
 \end{tabular}
\end{flushleft}
%
\paragraph{Accessing the string length}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|size_t QDP_string_ptr(const |\QMDhandle \verb|*const xml);|\\
    \hline
  Purpose        & Returns the length of the string. \\
   \hline
  Example        & \verb| length = QDP_string_length(xml);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
\paragraph{Destroying a QDP string}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|void QDP_string_destroy(|\QMDhandle \verb|*xml);|\\
    \hline
  Purpose        & Frees storage. \\
   \hline
  Example        & \verb|QDP_string_destroy(xml);| \\
   \hline
 \end{tabular}
\end{flushleft}
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation with QIO}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In addition to the usual header files required by QDP, the following
are also needed:
%
\begin{verbatim}
  qdpio.h
  qdp_string.h
\end{verbatim}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Appendix: QIO Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This appendix describes the QIO implementation currently shared by the
QDP/C and QDP++ cluster codes.  This implementation could stand on its
own as an API for non-SciDAC code.  The functionality is very similar
to that described above.  The reader is therefore referred to the
corresponding \verb|QDP| calls for a description of the shared
arguments.  The key difference is that the characteristics of internal
storage layout needed for QIO are encapsulated in a \verb|QDP_Layout|
structure, which must then be defined in any implementation, and the
information required for presenting field data in the correct byte
order is encapsulated in a ``factory'' function, which also must be
supplied by the implementer.

\paragraph{The layout structure}

The structure is defined as follows:
\begin{verbatim}
typedef struct {
  int (*node_number)(const int coords[]);
  int (*node_index)(const int coords[]);
  void (*get_coords)(int coords[], int node, int index);
  int *latsize;
  int latdim;
  size_t volume;
  size_t sites_on_node;
  int this_node;
  int number_of_nodes;
} QIO_Layout;
\end{verbatim}
%
The \verb|node_number| member is an implementer-supplied function
returning the number of the node that has the specified lattice
coordinate.  The \verb|node_index| member returns the storage order
index for the site on its node.  The \verb|get_coords| member maps the
node number and index values to lattice coordinates. The next two
members specify the lattice coordinate extent and spacetime dimension.
The sixth member specifies the full spacetime volume.  The seventh,
gives the number of sites on the current node, the eighth, the number
of the present node, and the last, the total number of nodes.

Here is an illustration of how the layout structure is loaded from the
data in our implementation of the QDP/C API prior to a
\verb|QIO_open_read| or \verb|QIO_open_write| call:
%
\begin{verbatim}
QIO_Layout layout;

layout.node_number = QDP_node_number;
layout.node_index  = QDP_index;
layout.get_coords = QDP_get_coords;
QDP_latsize(layout.latsize);
layout.latdim = QDP_ndim();
layout.volume = QDP_volume();
layout.sites_on_node = QDP_sites_on_node;
layout.this_node = QDP_this_node;
layout.number_of_nodes = QDP_numnodes();
\end{verbatim}

\paragraph{Open a file for writing}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|QIO_Writer *QIO_open_write(|\QMDhandle \verb|*xml_file,|\\
		 & \verb| char *filename, int serpar, int volfmt, int mode,| \\
                 & \verb| QIO_Layout *layout);| \\
  Purpose        & Opens a named file for writing and writes the file metadata. \\
\hline
  Example  & \verb|QIO_Writer *outfile;| \\
           & \verb|QIO_Layout layout;| \\
           & \verb|outfile = QIO_open_write(xml_file_out, filename, |\\
	   & \verb|  QDP_SERIAL, QDP_SINGLEFILE, QDP_CREATE, &layout); |\\
   \hline
 \end{tabular}
\end{flushleft}
%
It is assumed that the user has prepared the \verb|layout| argument as described above.

\paragraph{Open a file for reading}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|QIO_Reader *QIO_open_read(\QMDhandle *xml_file,,|\\
                 & \verb|  char *filename, int serpar, QIO_Layout *layout);|\\
  Purpose        & Opens a named file for writing and writes the file metadata. \\
\hline
  Example  & \verb|QDP_Reader *infile;| \\
           & \verb|QIO_Layout layout;| \\
           & \verb|infile = QIO_open_read(xml_file_in, filename, |\\
	   & \verb|  QDP_SERIAL, &layout);| \\
   \hline
 \end{tabular}
\end{flushleft}
%
The volume format is auto-detected so is not specified by the calling
program.  It is assumed that the user has prepared the \verb|layout|
argument as described above.


\paragraph{Close an output file}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QIO_close_write(QIO_Writer *out);| \\
\hline
  Example  & \verb|QIO_close_write(outfile);|\\
   \hline
 \end{tabular}
\end{flushleft}

\paragraph{Close an input file}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QIO_close_read(QIO_Reader *in);| \\
\hline
  Example  & \verb|QIO_close_read(infile);|\\
   \hline
 \end{tabular}
\end{flushleft}


\paragraph{Write a field, array of fields, or array of global data}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QIO_write(QIO_Writer *out, |\\
	    & \verb| QIO_RecordInfo *record_info,|\QMDhandle \verb|*xml_record, | \\
            & \verb| void (*get)(char *buf, size_t index, size_t count, void *arg),|\\
            & \verb| int datum_size, int word_size, void *arg);| \\
\hline
  Example  & \verb|QIO_RecordInfo *rec_info;| \\
           & \verb|rec_info = QIO_create_record_info(QDP_FIELD,"QDP_F_Real","F",|\\
           & \verb|0,QLA_Ns,size,1);| \\
           & \verb|QIO_write(outfile, rec_info, xml_record, QDP_F_get_R,|\\
           & \verb| sizeof(QLA_Real), sizeof(QLA_Real), (void *)field);|\\
   \hline
 \end{tabular}
\end{flushleft}
%
The input arguments are as follows:
\begin{flushleft}
\begin{tabular}{ll}
 \verb|out| & The \verb|QIO_Writer| handle returned by \verb|QIO_open_write|. \\
 \verb|record_info| & The private metadata for the record (see below). \\
 \verb|xml_record|  & The user-constructed metadata for the record. \\
 \verb|get|         & Factory function (see below). \\
 \verb|datum_size|  & The total number of bytes required to serialize the datum. \\
 \verb|word_size|   & The number of bytes in a datum word. \\
 \verb|arg|         & Pass-through parameters for the factory function. \\
\end{tabular}
\end{flushleft}
%
The fourth argument is a factory function that, in this example, is
invoked by QIO like this:
%
\begin{verbatim}
  QDP_F_get_R(buf, index, count, field);
\end{verbatim}
%
It is expected to fill the QIO-supplied buffer \verb|buf| with a
byte-serialized copy of the field datum at site index \verb|index|.
The parameter \verb|count| specifies the array length of the field
datum at that site.  The datum size parameter \verb|datum_size| gives
the total number of bytes to be delivered as the product of the count
parameter and the byte length of the array element on that site.

It is up to the applications programmer to assure that the data
base-type (int, float, double) word order produced by the factory
function follows the SciDAC convention for the specified datatype.
However byte ordering within a word (big endian or little endian)
processed by the factory functions should be in the native order of
the architecture.  Any byte rearrangement needed to convert to and
from standard file endianness is the responsibility of QIO.  To this
end the user must specify the base-type word length of the data in
bytes through the parameter \verb|word_size|.  All numeric SciDAC data
types are homogeneous in word size, so a single parameter
suffices.

For example for an array of four single precision color vector fields,
each consisting of three complex numbers, there are $4 \times 3 \times
2 = 24$ real values per site, each of them single-precision floating
point numbers.  The word size is 4 (bytes).  The factory function must
produce the standard word order: real part of the first color
component of the first color vector, followed by the imaginary part of
the same component, followed by the real and then imaginary parts of
the second color component of the first color vector, etc. The count
is 4 (color vectors), and the datum size is $4 \times 24 = 96$ (total
bytes per call).  [The type size of $3 \times 2 \times 4 = 12$ (bytes)
and the count of 4 (array elements) were specified when creating the
\verb|QIO_record_info| structure.]

The same factory function type is used for global and field data, even
though for global data the site \verb|index| parameter has no meaning.
For field data, QIO calls the factory function once per lattice site.
For global data, QIO calls only once and expects to take all the data
in that call.  It is the responsibility of the applications programmer
to provide the appropriate factory function for each case.

Since the open operation has already registered a \verb|node_number|
function, QIO knows to ask only for a site on the present node.  The
factory function is not required to fetch data from a different node.

The seventh argument of \verb|QIO_write| is passed back as the fourth
argument of the \verb|get| function.  It can be used to identify the
field from which the data is required.  In this way only one factory
function is needed for each QDP and QLA datatype.

\paragraph{Read a field, array of fields, or array of global data}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QIO_read(QIO_Reader *in,| \\
            & \verb| QIO_RecordInfo *record_info,| \QMDhandle \verb|*xml_record, |\\
	    & \verb| void (*put)(char *buf, int coords[], void *arg), |\\
            & \verb| int datum_size, void *arg);| \\
\hline
  Example  & \verb|QIO_read(infile, rec_info, xml_record, QDP_F_put_r, |\\
           & \verb| sizeof(QLA_Real), (void *)field);|\\
   \hline
 \end{tabular}
\end{flushleft}
%
This operation is the inverse of the write operation described.  The
\verb|put| factory function does the reverse of the \verb|get| function.

\paragraph{Read only the record metadata}

This utility makes it possible to examine only the header of the
record in order to decide whether to continue reading.  The state of
the file is remembered, so a subsequent call to \verb|QIO_read| reads
the full record as though this call had not been made.
%
\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QIO_read_record_info(QIO_Reader *in,| \\
                 & \verb| QIO_RecordInfo *record_info,| \QMDhandle \verb|*xml_record);| \\
\hline
  Example  & \verb|QIO_read_record_info(infile, rec_info, xml_record);|\\
   \hline
 \end{tabular}
\end{flushleft}
%

\paragraph{Skip to the next record}

\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QIO_next_record(QIO_Reader *in);| \\
\hline
  Example  & \verb|QIO_next_record(infile);|\\
   \hline
 \end{tabular}
\end{flushleft}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Private Record Metadata}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The private QIO record metadata is used for consistency checking.  It
carries enough information to completely define the binary record
format.  The \verb|QIO_RecordInfo| structure is opaque, but elements
are accessed and manipulated through the following functions:

\paragraph{Create the private record metadata structure}
Before writing a record the calling program must create the private
record metadata structure.  Before reading a record, the calling
program must allocate space for the private record metadata structure
using the same calling procedure.
%
\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|QIO_RecordInfo *QIO_create_record_info(int globaltype,| \\
                 & \verb|char *datatype, char *precision, int colors,| \\
                 & \verb| int spins, int typesize,| \\
                 & \verb| int datacount);| \\
\hline
  Example  & \verb|rec_info = QIO_create_record_info(QDP_FIELD,"QDP_F_Real","F",|\\
                 & \verb|0,0,size,1);|\\
   \hline
 \end{tabular}
\end{flushleft}
%
The \verb|globaltype| parameter distinguishes between a record
containing a QDP field and a record containing a QLA array.
%
\begin{verbatim}
  QDP_FIELD, QDP_GLOBAL
\end{verbatim}
%
for a QDP and a QLA record type, respectively.

The \verb|datatype| string is the name of one of the QLA datatypes.
The \verb|precision| string is one of these:
%
\begin{flushleft}
  \begin{tabular}{|l|l|}
\hline
    \verb|F| & single \\
    \verb|D| & double \\
    \verb|S| & random number generator state \\
    \verb|I| & integer (currently only 32-bit is supported)\\
\hline
  \end{tabular}
\end{flushleft}
%
The \verb|colors| and \verb|spins| arguments give the working value
for these quantities, if they apply to the datatype.  Otherwise, they
should be zero.  The \verb|typesize| specifies the number of bytes in
the QLA datatype and the \verb|datacount| specifies the number of such
datatypes per site.  So for a single precision SU(3) gauge field with
four color matrices per site, the typesize is 72 and the datacount is
4.

It is not an error to create a structure with zeros for integer values
and null string pointers.  Those data items are tagged as ``missing''.
However, \verb|QIO_write| and \verb|QIO_read| will return with an
error message, if the total byte count per site is inconsistent with
the values in this structure.

\paragraph{Destroy the private record metadata structure}
%
\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|void QIO_destroy_record_info(QIO_RecordInfo *record_info);| \\
\hline
  Example  & \verb|QIO_destroy_record_info(rec_info);|\\
   \hline
 \end{tabular}
\end{flushleft}
%

\paragraph{Compare two private record metadata structures}
To allow for verification that a record being read matches what is
expected, the calling program may create the record information
structure that it expects and compare it with the structure that
was read from the file.

%
\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QIO_compare_record_info(QIO_RecordInfo *found,|\\
                 & \verb| QIO_RecordInfo *expect);| \\
\hline
  Example  & \verb|int ok = QIO_compare_record_info(rec_info, cmp_info);|\\
   \hline
 \end{tabular}
\end{flushleft}
%
The arguments are {\it not} symmetric.  Only those fields that are
non-empty in the \verb|expect| structure are compared with fields in
the \verb|found| structure.

\paragraph{Extract individual values from the private record metadata structure}
The following accessors perform self-evident functions:

%
\begin{flushleft}
  \begin{tabular}{|l|l|}
  \hline
  Prototype      & \verb|int QIO_get_globaldata(QIO_RecordInfo *record_info);| \\
                 & \verb|char *QIO_get_datatype(QIO_RecordInfo *record_info);| \\
                 & \verb|char *QIO_get_precision(QIO_RecordInfo *record_info);| \\
                 & \verb|int QIO_get_colors(QIO_RecordInfo *record_info);| \\
                 & \verb|int QIO_get_spins(QIO_RecordInfo *record_info);| \\
                 & \verb|int QIO_get_typesize(QIO_RecordInfo *record_info);| \\
                 & \verb|int QIO_get_datacount(QIO_RecordInfo *record_info);| \\
\hline
 \end{tabular}
\end{flushleft}
%




 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Appendix: Multifile format}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The principal file read by the master node contains most of the metadata:

\begin{itemize}
  \item Private file QIO metadata
  \item User file physics metadata
  \item Binary index of sites
  \item Record 1 private QIO metadata
  \item Record 1 user physics metadata
  \item Record 1 binary data
  \item Record 1 private checksum
  \item Record 2 private QIO metadata
  \item Record 2 user physics metadata
  \item Record 2 binary data
  \item Record 2 private checksum
  \item etc.
\end{itemize}

The secondary files are given unique names, constructed by attaching
the file extension {\tt .vol}{\it nnn}, where {\it nnn} is the number
of the node that reads the file (with leading zeros).  The secondary
files contain these records:

\begin{itemize}
  \item Binary index of sites
  \item Record 1 binary data
  \item Record 2 binary data
  \item etc.
\end{itemize}

The site index in each case is a table of contents, that is, a list of
the linearized (lexicographic) ranks of all sites contained in the
file in the order of appearance.

Data is written in storage order.  At present it can be reread only to
the same layout.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Appendix: Data layout}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This appendix should specify in detail the layout of data for the
various QLA types.

\end{document}

